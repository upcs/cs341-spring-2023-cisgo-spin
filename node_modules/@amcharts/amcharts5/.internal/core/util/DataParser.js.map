{"version":3,"file":"DataParser.js","sourceRoot":"","sources":["../../../../../src/.internal/core/util/DataParser.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,KAAK,MAAM,QAAQ,CAAA;AAC/B,OAAO,KAAK,OAAO,MAAM,UAAU,CAAA;AAWnC;;;;;GAKG;AACH,MAAM,OAAO,UAAU;IAEtB;;;;;;OAMG;IACI,MAAM,CAAC,KAAK,CAAC,KAAa,EAAE,OAA4B;QAC9D,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;QACvC,IAAI;YACH,IAAI,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;gBAC1B,IAAI,IAAI,GAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;gBAC9B,IAAI,OAAO,CAAC,OAAO,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;oBAC3C,IAAI,CAAC,OAAO,EAAE,CAAC;iBACf;gBACD,OAAO,IAAI,CAAC;aACZ;iBACI,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;gBACvD,OAAO,KAAK,CAAC;aACb;iBACI;gBACJ,MAAK,CAAC,2BAA2B,CAAC,CAAC;aACnC;SACD;QAAC,OAAO,CAAC,EAAE;YACX,OAAO,SAAS,CAAC;SACjB;IACF,CAAC;IAES,MAAM,CAAC,cAAc,CAAC,OAA4B;QAC3D,MAAM,UAAU,GAAuB,EAAE,CAAC;QAC1C,MAAM,QAAQ,GAAG;YAChB,OAAO,EAAE,KAAK;SACd,CAAC;QACF,IAAI,CAAC,OAAO,EAAE;YACb,OAAO,GAAG,EAAE,CAAC;SACb;QACD,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;YACnC,UAAU,CAAC,GAAG,CAAC,GAAG,OAAQ,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC;QACxC,CAAC,CAAC,CAAC;QACH,OAAO,UAAU,CAAC;IACnB,CAAC;CACD;AAwCD;;;;;GAKG;AACH,MAAM,OAAO,SAAS;IAErB;;;;;;OAMG;IACI,MAAM,CAAC,KAAK,CAAC,KAAa,EAAE,OAA2B;QAC7D,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;QAEvC,wBAAwB;QACxB,IAAI,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,OAAO,CAAC,SAAU,CAAC,CAAC;QAEtD,sBAAsB;QACtB,IAAI,GAAG,GAAU,EAAE,EAClB,IAAI,GAAa,EAAE,EACnB,GAAW,EACX,CAAS,CAAC;QAEX,YAAY;QACZ,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,QAAS,EAAE,CAAC,EAAE,EAAE;YACvC,IAAI,CAAC,KAAK,EAAE,CAAC;SACb;QAED,gCAAgC;QAChC,IAAI,OAAO,CAAC,cAAc,EAAE;YAC3B,IAAI,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC;YAEpB,yBAAyB;YACzB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACrC,OAAO;gBACP,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,aAAa,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;gBAEhE,kBAAkB;gBAClB,IAAI,EAAE,KAAK,GAAG,EAAE;oBACf,GAAG,GAAG,KAAK,GAAG,CAAC,CAAC;iBAChB;gBAED,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;aACd;SACD;QAED,iCAAiC;QACjC,IAAI,GAAG,CAAC;QACR,OAAO,IAAI,EAAE;YACZ,GAAG,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC;YAElD,IAAI,CAAC,GAAG,EAAE;gBACT,MAAM;aACN;YAED,IAAI,OAAO,CAAC,SAAS,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;gBAC3D,SAAS;aACT;YAED,IAAI,SAAS,GAAQ,EAAE,CAAC;YACxB,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAChC,GAAG,GAAG,SAAS,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBAClD,SAAS,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;aACxB;YACD,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;SACpB;QAED,OAAO,GAAG,CAAC;IACZ,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,UAAU,CAAC,IAAY,EAAE,SAAiB;QAEvD,oDAAoD;QACpD,yBAAyB;QACzB,SAAS,GAAG,CAAC,SAAS,IAAI,GAAG,CAAC,CAAC;QAE/B,uDAAuD;QACvD,IAAI,UAAU,GAAG,IAAI,MAAM,CAC1B;QACC,cAAc;QACd,KAAK,GAAG,SAAS,GAAG,iBAAiB;YAErC,iBAAiB;YACjB,iCAAiC;YAEjC,mBAAmB;YACnB,SAAS,GAAG,SAAS,GAAG,YAAY,CACpC,EACD,IAAI,CACJ,CAAC;QAGF,mDAAmD;QACnD,6BAA6B;QAC7B,IAAI,OAAO,GAAU;YACpB,EAAE;SACF,CAAC;QAEF,iDAAiD;QACjD,mBAAmB;QACnB,IAAI,UAAU,GAAG,IAAI,CAAC;QAEtB,mDAAmD;QACnD,uCAAuC;QACvC,OAAO,IAAI,EAAE;YACZ,UAAU,GAAG,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAEnC,IAAI,CAAC,UAAU,EAAE;gBAChB,MAAM;aACN;YAED,oCAAoC;YACpC,IAAI,mBAAmB,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;YAExC,mDAAmD;YACnD,iDAAiD;YACjD,gDAAgD;YAChD,0CAA0C;YAC1C,IACC,mBAAmB,CAAC,MAAM;gBAC1B,CAAC,mBAAmB,KAAK,SAAS,CAAC,EAClC;gBAED,2CAA2C;gBAC3C,sCAAsC;gBACtC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;aAEjB;YAED,iDAAiD;YACjD,4CAA4C;YAC5C,iCAAiC;YACjC,IAAI,eAAe,CAAC;YACpB,IAAI,UAAU,CAAC,CAAC,CAAC,EAAE;gBAElB,2CAA2C;gBAC3C,0CAA0C;gBAC1C,eAAe,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC,OAAO,CACtC,IAAI,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,EACvB,IAAI,CACJ,CAAC;aAEF;iBAAM;gBAEN,+BAA+B;gBAC/B,eAAe,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;aAEhC;YAED,+CAA+C;YAC/C,wBAAwB;YACxB,OAAO,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;SAClD;QAED,0BAA0B;QAC1B,OAAO,CAAC,OAAO,CAAC,CAAC;IAClB,CAAC;IAES,MAAM,CAAC,cAAc,CAAC,OAA2B;QAC1D,MAAM,UAAU,GAAsB,EAAE,CAAC;QACzC,MAAM,QAAQ,GAAG;YAChB,SAAS,EAAE,GAAG;YACd,OAAO,EAAE,KAAK;YACd,QAAQ,EAAE,CAAC;YACX,SAAS,EAAE,IAAI;YACf,cAAc,EAAE,KAAK;SACrB,CAAC;QACF,IAAI,CAAC,OAAO,EAAE;YACb,OAAO,GAAG,EAAE,CAAC;SACb;QACD,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;YACnC,UAAU,CAAC,GAAG,CAAC,GAAG,OAAQ,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC;QACxC,CAAC,CAAC,CAAC;QACH,OAAO,UAAU,CAAC;IAEnB,CAAC;CAED","sourcesContent":["import * as $type from \"./Type\"\nimport * as $object from \"./Object\"\n\nexport interface IJSONParserOptions {\n\n\t/**\n\t * Reverse the order of parsed data.\n\t */\n\treverse?: boolean;\n\n}\n\n/**\n * Tool to parse JSON string into structured data.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Parsing} for more info\n * @important\n */\nexport class JSONParser {\n\n\t/**\n\t * Parses JSON string.\n\t * \n\t * @param   input    JSON\n\t * @param   options  Options\n\t * @return           Data\n\t */\n\tpublic static parse(input: string, options?: IJSONParserOptions): any {\n\t\toptions = this._applyDefaults(options);\n\t\ttry {\n\t\t\tif ($type.isString(input)) {\n\t\t\t\tlet data  = JSON.parse(input);\n\t\t\t\tif (options.reverse && $type.isArray(data)) {\n\t\t\t\t\tdata.reverse();\n\t\t\t\t}\n\t\t\t\treturn data;\n\t\t\t}\n\t\t\telse if ($type.isArray(input) || $type.isObject(input)) {\n\t\t\t\treturn input;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow(\"Unable to parse JSON data\");\n\t\t\t}\n\t\t} catch (e) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tprotected static _applyDefaults(options?: IJSONParserOptions): IJSONParserOptions {\n\t\tconst normalized: IJSONParserOptions = {};\n\t\tconst defaults = {\n\t\t\treverse: false\n\t\t};\n\t\tif (!options) {\n\t\t\toptions = {};\n\t\t}\n\t\t$object.each(defaults, (key, val) => {\n\t\t\tnormalized[key] = options![key] || val;\n\t\t});\n\t\treturn normalized;\n\t}\n}\n\n\nexport interface ICSVParserOptions {\n\n\t/**\n\t * Delimiter used for columns.\n\t * \n\t * @default \",\"\n\t */\n\tdelimiter?: string;\n\n\t/**\n\t * Reverse the order of parsed data.\n\t */\n\treverse?: boolean;\n\n\t/**\n\t * Skip first X rows.\n\t *\n\t * @default 0\n\t */\n\tskipRows?: number;\n\n\t/**\n\t * Skip empty rows.\n\t *\n\t * @default true\n\t */\n\tskipEmpty?: boolean;\n\n\t/**\n\t * Use the first row to name the columns.\n\t * \n\t * @default false\n\t */\n\tuseColumnNames?: boolean;\n\n}\n\n/**\n * Tool to parse JSON string into structured data.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Parsing} for more info\n * @important\n */\nexport class CSVParser {\n\n\t/**\n\t * Parses CSV string.\n\t * \n\t * @param   input    CSV\n\t * @param   options  Options\n\t * @return           Data\n\t */\n\tpublic static parse(input: string, options?: ICSVParserOptions): any {\n\t\toptions = this._applyDefaults(options);\n\n\t\t// Get CSV data as array\n\t\tlet data = this.CSVToArray(input, options.delimiter!);\n\n\t\t// Init resuling array\n\t\tlet res: any[] = [],\n\t\t\tcols: string[] = [],\n\t\t\tcol: string,\n\t\t\ti: number;\n\n\t\t// Skip rows\n\t\tfor (i = 0; i < options.skipRows!; i++) {\n\t\t\tdata.shift();\n\t\t}\n\n\t\t// First row holds column names?\n\t\tif (options.useColumnNames) {\n\t\t\tcols = data.shift();\n\n\t\t\t// Normalize column names\n\t\t\tfor (let x = 0; x < cols.length; x++) {\n\t\t\t\t// trim\n\t\t\t\tcol = cols[x] != null ? cols[x].replace(/^\\s+|\\s+$/gm, \"\") : \"\";\n\n\t\t\t\t// Check for empty\n\t\t\t\tif (\"\" === col) {\n\t\t\t\t\tcol = \"col\" + x;\n\t\t\t\t}\n\n\t\t\t\tcols[x] = col;\n\t\t\t}\n\t\t}\n\n\t\t// Iterate through the result set\n\t\tlet row;\n\t\twhile (true) {\n\t\t\trow = options.reverse ? data.pop() : data.shift();\n\n\t\t\tif (!row) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (options.skipEmpty && row.length === 1 && row[0] === \"\") {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet dataPoint: any = {};\n\t\t\tfor (i = 0; i < row.length; i++) {\n\t\t\t\tcol = undefined === cols[i] ? \"col\" + i : cols[i];\n\t\t\t\tdataPoint[col] = row[i];\n\t\t\t}\n\t\t\tres.push(dataPoint);\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic static CSVToArray(data: string, delimiter: string): any[] {\n\n\t\t// Check to see if the delimiter is defined. If not,\n\t\t// then default to comma.\n\t\tdelimiter = (delimiter || ',');\n\n\t\t// Create a regular expression to parse the CSV values.\n\t\tlet objPattern = new RegExp(\n\t\t\t(\n\t\t\t\t// Delimiters.\n\t\t\t\t\"(\\\\\" + delimiter + \"|\\\\r?\\\\n|\\\\r|^)\" +\n\n\t\t\t\t// Quoted fields.\n\t\t\t\t\"(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|\" +\n\n\t\t\t\t// Standard fields.\n\t\t\t\t\"([^\\\"\\\\\" + delimiter + \"\\\\r\\\\n]*))\"\n\t\t\t),\n\t\t\t\"gi\"\n\t\t);\n\n\n\t\t// Create an array to hold our data. Give the array\n\t\t// a default empty first row.\n\t\tlet arrData: any[] = [\n\t\t\t[]\n\t\t];\n\n\t\t// Create an array to hold our individual pattern\n\t\t// matching groups.\n\t\tlet arrMatches = null;\n\n\t\t// Keep looping over the regular expression matches\n\t\t// until we can no longer find a match.\n\t\twhile (true) {\n\t\t\tarrMatches = objPattern.exec(data);\n\n\t\t\tif (!arrMatches) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Get the delimiter that was found.\n\t\t\tlet strMatchedDelimiter = arrMatches[1];\n\n\t\t\t// Check to see if the given delimiter has a length\n\t\t\t// (is not the start of string) and if it matches\n\t\t\t// field delimiter. If id does not, then we know\n\t\t\t// that this delimiter is a row delimiter.\n\t\t\tif (\n\t\t\t\tstrMatchedDelimiter.length &&\n\t\t\t\t(strMatchedDelimiter !== delimiter)\n\t\t\t) {\n\n\t\t\t\t// Since we have reached a new row of data,\n\t\t\t\t// add an empty row to our data array.\n\t\t\t\tarrData.push([]);\n\n\t\t\t}\n\n\t\t\t// Now that we have our delimiter out of the way,\n\t\t\t// let's check to see which kind of value we\n\t\t\t// captured (quoted or unquoted).\n\t\t\tlet strMatchedValue;\n\t\t\tif (arrMatches[2]) {\n\n\t\t\t\t// We found a quoted value. When we capture\n\t\t\t\t// this value, unescape any double quotes.\n\t\t\t\tstrMatchedValue = arrMatches[2].replace(\n\t\t\t\t\tnew RegExp(\"\\\"\\\"\", \"g\"),\n\t\t\t\t\t\"\\\"\"\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// We found a non-quoted value.\n\t\t\t\tstrMatchedValue = arrMatches[3];\n\n\t\t\t}\n\n\t\t\t// Now that we have our value string, let's add\n\t\t\t// it to the data array.\n\t\t\tarrData[arrData.length - 1].push(strMatchedValue);\n\t\t}\n\n\t\t// Return the parsed data.\n\t\treturn (arrData);\n\t}\n\n\tprotected static _applyDefaults(options?: ICSVParserOptions): ICSVParserOptions {\n\t\tconst normalized: ICSVParserOptions = {};\n\t\tconst defaults = {\n\t\t\tdelimiter: \",\",\n\t\t\treverse: false,\n\t\t\tskipRows: 0,\n\t\t\tskipEmpty: true,\n\t\t\tuseColumnNames: false\n\t\t};\n\t\tif (!options) {\n\t\t\toptions = {};\n\t\t}\n\t\t$object.each(defaults, (key, val) => {\n\t\t\tnormalized[key] = options![key] || val;\n\t\t});\n\t\treturn normalized;\n\n\t}\n\n}"]}