{"version":3,"file":"TextFormatter.js","sourceRoot":"","sources":["../../../../../src/.internal/core/util/TextFormatter.ts"],"names":[],"mappings":"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","sourcesContent":["import { Color } from \"./Color\"\nimport type { ITextStyle } from \"../render/backend/Renderer\"\nimport * as $type from \"./Type\";\n\n/**\n * Defines an interface for an object that holds a chunk of text.\n */\nexport interface ITextChunk {\n\n\t/**\n\t * Type of the chunk.\n\t */\n\t\"type\": \"value\" | \"text\" | \"format\" | \"image\",\n\n\t/**\n\t * Text.\n\t */\n\t\"text\": string\n\n}\n\nexport class TextFormatter {\n\n\tpublic static prefix = \"__amcharts__\";\n\n\t/**\n\t * Replaces brackets with temporary placeholders.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text  Input text\n\t * @return Escaped text\n\t */\n\tpublic static escape(text: string): string {\n\t\treturn text.\n\t\t\treplace(/\\[\\[/g, this.prefix + \"1\").\n\t\t\treplace(/([^\\/\\]]{1})\\]\\]/g, \"$1\" + this.prefix + \"2\").\n\t\t\treplace(/\\]\\]/g, this.prefix + \"2\").\n\t\t\treplace(/\\{\\{/g, this.prefix + \"3\").\n\t\t\treplace(/\\}\\}/g, this.prefix + \"4\").\n\t\t\treplace(/\\'\\'/g, this.prefix + \"5\");\n\t}\n\n\t/**\n\t * Replaces placeholders back to brackets.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text  Escaped text\n\t * @return Unescaped text\n\t */\n\tpublic static unescape(text: string): string {\n\t\treturn text.\n\t\t\treplace(new RegExp(this.prefix + \"1\", \"g\"), \"[[\").\n\t\t\treplace(new RegExp(this.prefix + \"2\", \"g\"), \"]]\").\n\t\t\treplace(new RegExp(this.prefix + \"3\", \"g\"), \"{{\").\n\t\t\treplace(new RegExp(this.prefix + \"4\", \"g\"), \"}}\").\n\t\t\treplace(new RegExp(this.prefix + \"5\", \"g\"), \"''\");\n\t}\n\n\t/**\n\t * Cleans up the text text for leftover double square brackets.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text  Input text\n\t * @return Cleaned up text\n\t */\n\tpublic static cleanUp(text: string): string {\n\t\treturn text.\n\t\t\treplace(/\\[\\[/g, \"[\").\n\t\t\treplace(/\\]\\]/g, \"]\").\n\t\t\treplace(/\\{\\{/g, \"{\").\n\t\t\treplace(/\\}\\}/g, \"}\").\n\t\t\treplace(/\\'\\'/g, \"'\");\n\t}\n\n\t/**\n\t * Splits string into chunks. (style blocks, quoted blocks, regular blocks)\n\t *\n\t * If the second parameter `quotedBlocks` is set to `true` this method will\n\t * also single out text blocks enclosed within single quotes that no\n\t * formatting should be applied to, and they should be displayed as is.\n\t *\n\t * Default for the above is `false`, so that you can use single quote in text\n\t * without escaping it.\n\t *\n\t * If enabled, single quotes can be escaped by doubling it - adding two\n\t * single quotes, which will be replaced by a one single quote in the final\n\t * output.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text          Text to chunk\n\t * @param quotedBlocks  Use quoted blocks\n\t * @param noFormatting  Formatting blocks will be treated as regular text\n\t * @return Array of string chunks\n\t */\n\tpublic static chunk(text: string, quotedBlocks: boolean = false, noFormatting: boolean = false): ITextChunk[] {\n\n\t\t// Init result\n\t\tlet res: ITextChunk[] = [];\n\n\t\t// Replace double (escaped) square spaces and quotes with temporary codes\n\t\ttext = this.escape(text);\n\n\t\t// Deal with style blocks\n\t\tlet chunks = quotedBlocks ? text.split(\"'\") : [text];\n\t\tfor (let i: number = 0; i < chunks.length; i++) {\n\t\t\tlet chunk = chunks[i];\n\n\t\t\t// Empty?\n\t\t\tif (chunk === \"\") {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((i % 2) === 0) {\n\n\t\t\t\t// Text outside quotes\n\t\t\t\t// Parse for style blocks which are \"text\" chunks, the rest chunks are\n\t\t\t\t// \"value\"\n\n\t\t\t\tchunk = chunk.replace(/\\]\\[/g, \"]\" + $type.PLACEHOLDER + \"[\");\n\t\t\t\tchunk = chunk.replace(/\\[\\]/g, \"[ ]\");\n\t\t\t\tlet chunks2 = chunk.split(/[\\[\\]]+/);\n\t\t\t\tfor (let i2: number = 0; i2 < chunks2.length; i2++) {\n\t\t\t\t\tlet chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\n\n\t\t\t\t\t// Placeholder?\n\t\t\t\t\tif (chunk2 === $type.PLACEHOLDER) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Empty?\n\t\t\t\t\tif (chunk2 === \"\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Block or value\n\t\t\t\t\tif ((i2 % 2) === 0) {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"value\",\n\t\t\t\t\t\t\t\"text\": chunk2\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": noFormatting ? \"value\" : \"format\",\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// A text within doublequotes\n\t\t\t\t// All chunks are \"text\"\n\n\t\t\t\tlet chunks2 = chunk.split(/[\\[\\]]+/);\n\t\t\t\tfor (let i2: number = 0; i2 < chunks2.length; i2++) {\n\t\t\t\t\tlet chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\n\n\t\t\t\t\t// Empty?\n\t\t\t\t\tif (chunk2 === \"\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Block or text\n\t\t\t\t\tif ((i2 % 2) === 0) {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\"text\": chunk2\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse if (this.isImage(chunk2)) {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"image\",\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"format\",\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * Checks if supplied format contains image information and should be\n\t * formatted as such.\n\t * I.e.: `[img: myImage.png]`\n\t *\n\t * @ignore\n\t * @param  text  Format\n\t * @return true if it is an image\n\t */\n\tpublic static isImage(text: string): boolean {\n\t\treturn text.match(/img[ ]?:/) ? true : false;\n\t}\n\n\tpublic static getTextStyle(style: string): ITextStyle {\n\n\t\t// let textStyle: string[] = [];\n\t\t// let textFill: string | undefined;\n\t\tlet format: ITextStyle = {};\n\n\t\tif (style == \"\" || style == \"[ ]\") {\n\t\t\treturn {};\n\t\t}\n\n\t\t// Pre-process quoted text\n\t\tconst q = style.match(/('[^']*')|(\"[^\"]*\")/gi);\n\t\tif (q) {\n\t\t\tfor (let i: number = 0; i < q.length; i++) {\n\t\t\t\tstyle = style.replace(q[i], q[i].replace(/['\"]*/g, \"\").replace(/[ ]+/g, \"+\"));\n\t\t\t}\n\t\t}\n\n\t\t// Get style parts\n\t\tlet b: string[] | null = style.match(/([\\w\\-]*:[\\s]?[^;\\s\\]]*)|(\\#[\\w]{1,6})|([\\w\\-]+)|(\\/)/gi);\n\n\t\t// Empty?\n\t\tif (!b) {\n\t\t\treturn {};\n\t\t}\n\n\t\t// Check each part\n\t\tfor (let i: number = 0; i < b.length; i++) {\n\n\t\t\tif (b[i].match(/^(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)$/i)) {\n\t\t\t\t(<any>format).fontWeight = b[i];\n\t\t\t}\n\t\t\telse if (b[i].match(/^(underline|line-through)$/i)) {\n\t\t\t\t(<any>format).textDecoration = b[i];\n\t\t\t}\n\t\t\telse if (b[i] == \"/\") {\n\t\t\t\t// Just closing tag\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t\telse if (!b[i].match(/:/)) {\n\t\t\t\t// Color\n\t\t\t\tformat.fill = Color.fromString(b[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst p = b[i].replace(\"+\", \" \").split(/:[ ]*/);\n\t\t\t\t(<any>format)[p[0]] = p[1];\n\t\t\t\t//textStyle.push(b[i].replace(/^[a-zA-Z]:[ ]*/, \"\"));\n\t\t\t\t//b[i] = b[i].replace(/\\+/g, \" \");\n\t\t\t}\n\n\t\t}\n\n\t\treturn format;\n\t}\n\n}\n"]}